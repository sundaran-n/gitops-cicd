name: Release Pipeline with Property Updates

on:
  workflow_dispatch:
    inputs:
      release:
        description: "Release Version"
        required: true
        type: string

jobs:
  read-inputs:
    runs-on: ubuntu-latest
    outputs:
      iteration: ${{ steps.extract.outputs.ITERATION }}
      imagetag: ${{ steps.extract.outputs.IMAGETAG }}
      db: ${{ steps.extract.outputs.DB }}
      base_path: ${{ steps.extract.outputs.BASE_PATH }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Read Inputs from File
        id: extract
        run: |
          RELEASE_VERSION=${{ inputs.release }}
          FILE_PATH="release/${RELEASE_VERSION}/input.txt"

          if [ ! -f "$FILE_PATH" ]; then
            echo "::error:: File not found: $FILE_PATH"
            exit 1
          fi

          ITERATION=$(awk '/\[ITERATION\]/{getline; print}' $FILE_PATH | tr -d '[:space:]')
          IMAGETAG=$(awk '/\[IMAGETAG\]/ {flag=1; next} /\[DB\]/ {flag=0} flag' $FILE_PATH | tr '\n' ',' | sed 's/,$//')
          DB=$(awk '/\[DB\]/{getline; print}' $FILE_PATH | tr -d '[:space:]')

          BASE_PATH="release/${RELEASE_VERSION}"

          echo "ITERATION=$ITERATION" >> $GITHUB_OUTPUT
          echo "IMAGETAG=$IMAGETAG" >> $GITHUB_OUTPUT
          echo "DB=$DB" >> $GITHUB_OUTPUT
          echo "BASE_PATH=$BASE_PATH" >> $GITHUB_OUTPUT

  update-properties:
    needs: read-inputs
    runs-on: ubuntu-latest
    env:
      TARGET_REPO: "my-org/target-repo"
      PROPERTIES_BRANCH: "main"
      RELEASE_BRANCH: "releasemanagement"
    steps:
      - name: Checkout Target Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ env.PROPERTIES_BRANCH }}
          token: ${{ secrets.PAT_TOKEN }}

      - name: Set up Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch and Checkout Release Folder from Target Repo
        run: |
          BASE_PATH="${{ needs.read-inputs.outputs.base_path }}"
          RELEASE_BRANCH="${{ env.RELEASE_BRANCH }}"

          echo "Fetching release branch: $RELEASE_BRANCH from ${{ env.TARGET_REPO }}"
          git fetch origin "$RELEASE_BRANCH" || { echo "::error:: Branch $RELEASE_BRANCH not found!"; exit 1; }

          echo "Checking out release folder from branch: $RELEASE_BRANCH"
          git checkout origin/"$RELEASE_BRANCH" -- "$BASE_PATH" || { echo "::error:: Release folder not found in $RELEASE_BRANCH!"; exit 1; }

          [ -d "$BASE_PATH" ] || { echo "::error:: [ERROR] Release folder does not exist: $BASE_PATH"; exit 1; }

      - name: Process Property File Changes (Strict Validation)
        run: |
          BASE_PATH="${{ needs.read-inputs.outputs.base_path }}"
          FULL_PATH="$GITHUB_WORKSPACE/$BASE_PATH"
          LOG_FILE="property_changes.log"

          echo "Processing property file changes..." > "$LOG_FILE"

          find "$FULL_PATH" -type f | while read -r FILE_PATH; do
            FILE_NAME=$(basename "$FILE_PATH")
            MATCHING_PROPERTY_FILE="$FILE_NAME.properties"

            if [ ! -f "$MATCHING_PROPERTY_FILE" ]; then
              echo "::error:: [ERROR] Property file '$MATCHING_PROPERTY_FILE' not found in repo!" | tee -a "$LOG_FILE"
              exit 1
            fi

            TEMP_FILE="${MATCHING_PROPERTY_FILE}.tmp"
            cp "$MATCHING_PROPERTY_FILE" "$TEMP_FILE"

            SECTION=""
            while IFS= read -r line; do
              [[ -z "$line" || "$line" =~ ^# ]] && continue

              case "$line" in
                "[ADD]") SECTION="ADD"; continue ;;
                "[UPDATE]") SECTION="UPDATE"; continue ;;
                "[REMOVE]") SECTION="REMOVE"; continue ;;
              esac

              KEY=$(echo "$line" | cut -d= -f1)
              VALUE=$(echo "$line" | cut -d= -f2-)

              case "$SECTION" in
                "ADD")
                  if grep -q "^$KEY=" "$TEMP_FILE"; then
                    echo "::error:: [ERROR] Key '$KEY' already exists in $MATCHING_PROPERTY_FILE, ADD operation failed!" | tee -a "$LOG_FILE"
                    exit 1
                  fi
                  echo "$line" >> "$TEMP_FILE"
                  ;;
                "UPDATE")
                  if grep -q "^$KEY=" "$TEMP_FILE"; then
                    OLD_VALUE=$(grep "^$KEY=" "$TEMP_FILE" | cut -d= -f2-)
                    if [[ "$OLD_VALUE" == "$VALUE" ]]; then
                      echo "::error:: [ERROR] Key '$KEY' already has the same value in $MATCHING_PROPERTY_FILE, UPDATE operation failed!" | tee -a "$LOG_FILE"
                      exit 1
                    else
                      sed -i "s|^$KEY=.*|$KEY=$VALUE|" "$TEMP_FILE"
                    fi
                  else
                    echo "::error:: [ERROR] Key '$KEY' not found in $MATCHING_PROPERTY_FILE, UPDATE operation failed!" | tee -a "$LOG_FILE"
                    exit 1
                  fi
                  ;;
                "REMOVE")
                  if grep -q "^$KEY=" "$TEMP_FILE"; then
                    sed -i "/^$KEY=/d" "$TEMP_FILE"
                  else
                    echo "::error:: [ERROR] Key '$KEY' not found in $MATCHING_PROPERTY_FILE, REMOVE operation failed!" | tee -a "$LOG_FILE"
                    exit 1
                  fi
                  ;;
              esac
            done < "$FILE_PATH"

            mv "$TEMP_FILE" "$MATCHING_PROPERTY_FILE"
          done

      - name: Commit and Push Changes to Target Repo
        run: |
          git add -u
          if git diff --cached --quiet; then
            echo "No changes detected, skipping commit."
            exit 0
          fi
          git commit -m "Updated properties from release folder: ${{ needs.read-inputs.outputs.base_path }}"
          git push origin "${{ env.PROPERTIES_BRANCH }}" || { echo "::error:: Push failed!"; exit 1; }

  deploy:
    needs: [read-inputs, update-properties]
    runs-on: ubuntu-latest
    permissions:
      id-token: write 
      contents: read 
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Account
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::977186631846:role/GitHubActionsEKSRole
          aws-region: us-east-2

      - name: Apply Kubernetes Manifests
        run: |
          IFS=',' read -r -a IMAGES <<< "${{ needs.read-inputs.outputs.imagetag }}"
          for IMAGE in "${IMAGES[@]}"; do
            SERVICE=$(echo $IMAGE | cut -d'_' -f1)
            YAML_FILE="manifest/${SERVICE}.yaml"
            [ -f "$YAML_FILE" ] && kubectl apply -f "$YAML_FILE"
          done